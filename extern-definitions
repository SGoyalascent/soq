http://stackoverflow.com/questions/1433204
Q: What are extern variables in C?
Q: How do I share a variable between source files in C? With extern, but how?

Using `extern` is only of relevance when the program you're building
consists of multiple source files linked together, where some of the
variables defined, for example, in source file `file1.c` need to be
referenced in other source files, such as `file2.c`.

It is important to [understand the difference between _defining_ a
variable and _declaring_ a variable][1]:

* A variable is **defined** when the compiler allocates the storage for
  the variable.
* A variable is **declared** when the compiler is informed that a
  variable exists (and this is its type); it does not allocate the
  storage for the variable at that point.

You may declare a variable multiple times (though once is sufficient);
you may only define it once within a given scope.

## Best way to declare and define global variables

Although there are other ways of doing it, the clean, reliable way to
declare and define global variables is to use a header file `file3.h` to
contain an `extern` _declaration_ of the variable.  The header is
included by the one source file that defines the variable and by all the
source files that reference the variable.  For each program, one source
file (and only one source file) defines the variable.  Similarly, one
header file (and only one header file) should declare the variable.

### file3.h

    extern int global_variable;  /* Declaration of the variable */

### file1.c

    #include "file3.h"  /* Declaration made available here */
    #include "prog1.h"  /* Function declarations */

    /* Variable defined here */
    int global_variable = 37;    /* Definition checked against declaration */

    int increment(void) { return global_variable++; }

### file2.c

    #include "file3.h"
    #include "prog1.h"
    #include <stdio.h>

    void use_it(void)
    {
        printf("Global variable: %d\n", global_variable++);
    }

That's the best way to use them.

_The next two files complete the source for `prog1`:_

### prog1.h

    extern void use_it(void);
    extern int increment(void);

### prog1.c

    #include "file3.h"
    #include "prog1.h"
    #include <stdio.h>

    int main(void)
    {
        use_it();
        global_variable += 19;
        use_it();
        printf("Increment: %d\n", increment());
        return 0;
    }

## Guidelines

Rules to be broken by experts only, and only with good reason:

* A header file only contains `extern` declarations of variables — never
  `static` or unqualified variable definitions.
* For any given variable, only one header file declares it (SPOT —
  Single Point of Truth).
* A source file never contains `extern` declarations of variables —
  source files always include the (sole) header that declares them.
* For any given variable, exactly one source file defines the variable,
  preferably initializing it too.  (Although there is no need to
  initialize explicitly to zero, it does no harm and can do some good,
  because there can be only one initialized definition of a particular
  global variable in a program).
* The source file that defines the variable also includes the header to
  ensure that the definition and the declaration are consistent.
* A function should never need to declare a variable using `extern`.
* Avoid global variables whenever possible — use functions instead.

## Not so good way to define global variables

With some (indeed, many) C compilers, you can get away with what's
called a 'common' definition of a variable too.  'Common', here, refers
to a technique used in Fortran for sharing variables between source
files, using a (possibly named) COMMON block.  What happens here is that
each of a number of files provides a tentative definition of the
variable.  As long as no more than one file provides an initialized
definition, then the various files end up sharing a common single
definition of the variable:

### file10.c

    #include "prog2.h"

    int i;   /* Do not do this in portable code */

    void inc(void) { i++; }

### file11.c

    #include "prog2.h"

    int i;   /* Do not do this in portable code */

    void dec(void) { i--; }

### file12.c

    #include "prog2.h"

    int i = 9;   /* Do not do this in portable code */

    void put(void) { printf("i = %d\n", i); }

This technique does not conform to the letter of the C standard and the
'one definition rule', but the C standard lists it as a common variation
on its one definition rule.
Because this technique is not always supported, it is best to avoid
using it, _especially if your code needs to be portable_.  Using this
technique, you can also end up with unintentional type punning.  If one
of the files declared `i` as a `double` instead of as an `int`, C's
type-unsafe linkers probably would not spot the mismatch.  If you're on
a machine with 64-bit `int` and `double`, you'd not even get a warning;
on a machine with 32-bit `int` and 64-bit `double`, you'd probably get a
warning about the different sizes — the linker would use the largest
size, exactly as a Fortran program would take the largest size of any
common blocks.

This is mentioned in the C standard in informative Annex J as a common
extension:

> J.5.11 Multiple external definitions

>There may be more than one external definition for the identifier of an
object, with or without the explicit use of the keyword extern; if the
definitions disagree, or more than one is initialized, the behavior is
undefined (6.9.2).

_The next two files complete the source for `prog2`:_

### prog2.h

    extern void dec(void);
    extern void put(void);
    extern void inc(void);

### prog2.c

    #include "prog2.h"
    #include <stdio.h>

    int main(void)
    {
        inc();
        put();
        dec();
        put();
        dec();
        put();
    }

### Warning

As noted in comments here, and as stated in my answer to a similar
[question][2], using multiple definitions for a global variable leads to
undefined behaviour, which is the standard's way of saying "anything
could happen".  One of the things that can happen is that the program
behaves as you expect; and J.5.11 says, approximately, "you might be
lucky more often than you deserve".  But a program that relies on
multiple definitions of an extern variable — with or without the
explicit 'extern' keyword — is not a strictly conforming program and not
guaranteed to work everywhere.  Equivalently: it contains a bug which
may or may not show itself.

## Violating the guidelines

Note 1: if the header defines the variable without the `extern` keyword:

### faulty_header.h

    int some_var;    /* Do not do this in a header!!! */

Then each file that includes the header creates a tentative definition
of the variable.

Note 2: if the header defines and initializes the variable, then only
one source file in a given program can use the header:

### broken_header.h

    int some_var = 13;    /* Only one source file in a program can use this */

Note 3: if the header defines a static variable (with or without
initialization), then each source file ends up with its own private
version of the 'global' variable.

### seldom_correct.h

    static int hidden_global = 3;   /* Each source file gets its own copy  */

When the variable is actually a complex array, this can lead to extreme
duplication of code.  It can, very occasionally, be a sensible way to
achieve some effect, but that is rather unusual.

<hr>

Use the header technique I showed first.  It works reliably and
everywhere.  Note, in particular, that the header declaring the
`global_variable` is included in every file that uses it — including the
one that defines it.  This ensures that everything is self-consistent.

Similar concerns arise with declaring and defining functions — analogous
rules apply.  But the question was about variables specifically, so I've
kept the answer to variables only.

(The complete programs use functions, so function declarations have
crept in.  I use the keyword `extern` in front of function declarations
in headers to match the `extern` in front of variable declarations in
headers.  Many people prefer not to use `extern` in front of functions;
the compiler doesn't care — and ultimately, neither do I as long as
you're consistent.)

### End of Original Answer

<hr>

_Late Major Addition_

# Avoiding Code Duplication

One concern that is sometimes (and legitimately) raised about the
'declarations in headers, definitions in source' mechanism described
here is that there are two files to be kept synchronized — the header
and the source.  This is usually followed up with an observation that a
macro can be used so that the header serves double duty — normally
declaring the variables, but when a specific macro is set before the
header is included, it defines the variables instead.

Another concern can be that the variables need to be defined in each of
a number of 'main programs'.  This is normally a spurious concern; you
can simply introduce a C source file to define the variables and link
the object file produced with each of the programs.

A typical scheme works like this, using the original global variable
illustrated in `file3.h`:

### file3a.h

    #ifdef DEFINE_VARIABLES
    #define EXTERN /* nothing */
    #else
    #define EXTERN extern
    #endif /* DEFINE_VARIABLES */

    EXTERN int global_variable;

### file1a.c

    #define DEFINE_VARIABLES
    #include "file3a.h"  /* Variable defined - but not initialized */
    #include "prog3.h"

    int increment(void) { return global_variable++; }

### file2a.c

    #include "file3a.h"
    #include "prog3.h"
    #include <stdio.h>

    void use_it(void)
    {
        printf("Global variable: %d\n", global_variable++);
    }

_The next two files complete the source for `prog3`:_

### prog3.h

    extern void use_it(void);
    extern int increment(void);

### prog3.c

    #include "file3a.h"
    #include "prog3.h"
    #include <stdio.h>

    int main(void)
    {
        use_it();
        global_variable += 19;
        use_it();
        printf("Increment: %d\n", increment());
        return 0;
    }

The problem with this scheme as shown is that it does not provide for
initialization of the global variable.  With C99 or C11 and variable argument
lists for macros, you could define a macro to support initialization too.
(With C89 and no support for variable argument lists in macros, there is no
easy way to handle arbitrarily long initializers.)

### file3b.h

    #ifdef DEFINE_VARIABLES
    #define EXTERN                  extern
    #define INITIALIZER(...)        /* nothing */
    #else
    #define EXTERN                  /* nothing */
    #define INITIALIZER(...)        = __VA_ARGS__
    #endif /* DEFINE_VARIABLES */

    EXTERN int global_variable INITIALIZER(37);
    EXTERN struct { int a; int b; } oddball_struct INITIALIZER({ 41, 43 });

<sup>Reverse contents of `#if` and `#else` blocks, fixing bug identified by
[Denis Kniazhev](http://stackoverflow.com/users/369317/denis-kniazhev)</sup>

### file1b.c

    #define DEFINE_VARIABLES
    #include "file3b.h"  /* Variables now defined and initialized */

    int increment(void) { return global_variable++; }
    int oddball_value(void) { return oddball_struct.a + oddball_struct.b; }

### file2b.c

    #include "file3b.h"
    #include <stdio.h>

    void use_them(void)
    {
        printf("Global variable: %d\n", global_variable++);
        oddball_struct.a += global_variable;
        oddball_struct.b -= global_variable / 2;
    }

Clearly, the code for the oddball structure is not what you'd normally
write, but it illustrates the point.  The first argument to the second
invocation of `INITIALIZER` is `{ 41` and the remaining argument
(singular in this example) is `43 }`.  Without C99 or similar support
for variable argument lists for macros, initializers that need to
contain commas are very problematic.

<sup>Correct header `file3b.h` included (instead of `fileba.h`) per
[Denis Kniazhev](http://stackoverflow.com/users/369317/denis-kniazhev)</sup>

_The next two files complete the source for `prog4`:_

### prog4.h

    extern int increment(void);
    extern int oddball_value(void);
    extern void use_them(void);

### prog4.c

    #include "file3b.h"
    #include "prog4.h"
    #include <stdio.h>

    int main(void)
    {
        use_them();
        global_variable += 19;
        use_them();
        printf("Increment: %d\n", increment());
        printf("Oddball:   %d\n", oddball_value());
        return 0;
    }

## Header Guards

Any header should be protected against reinclusion, so that type
definitions (enum, struct or union types, or typedefs generally) do not
cause problems.  The standard technique is to wrap the body of the
header in a header guard:

    #ifndef FILE3B_H_INCLUDED
    #define FILE3B_H_INCLUDED

    ...contents of header...

    #endif /* FILE3B_H_INCLUDED */

The header might be included twice indirectly.  For example, if
`file4b.h` includes `file3b.h` for a type definition that isn't shown,
and `file1b.c` needs to use both header `file4b.h` and `file3b.h`, then
you have some more tricky issues to resolve.  Clearly, you might revise
the header list to include just `file4b.h`.  However, you might not be
aware of the internal dependencies — and the code should, ideally,
continue to work.

Further, it starts to get tricky because you might include `file4b.h`
before including `file3b.h` to generate the definitions, but the normal
header guards on `file3b.h` would prevent the header being reincluded.

So, you need to include the body of `file3b.h` at most once for
declarations, and at most once for definitions, but you might need both
in a single translation unit (TU — a combination of a source file and
the headers it uses).

## Multiple inclusion with variable definitions

However, it can be done subject to a not too unreasonable constraint.
Let's introduce a new set of file names:

* `external.h` for the EXTERN macro definitions, etc.
* `file1c.h` to define types (notably, `struct oddball`, the type of `oddball_struct`).
* `file2c.h` to define or declare the global variables.
* `file3c.c` which defines the global variables.
* `file4c.c` which simply uses the global variables.
* `file5c.c` which shows that you can declare and then define the global variables.
* `file6c.c` which shows that you can define and then (attempt to) declare the global variables.

In these examples, `file5c.c` and `file6c.c` directly include the header
`file2c.h` several times, but that is the simplest way to show that the
mechanism works.  It means that if the header was indirectly included
twice, it would also be safe.

The restrictions for this to work are:

1. The header defining or declaring the global variables may not itself
   define any types.
2. Immediately before you include a header that should define variables,
   you define the macro DEFINE_VARIABLES.
3. The header defining or declaring the variables has stylized contents.

### external.h

    /*
    ** This header must not contain header guards (like <assert.h> must not).
    ** Each time it is invoked, it redefines the macros EXTERN and INITIALIZER
    ** based on whether macro DEFINE_VARIABLES is currently defined.
    */
    #undef EXTERN
    #undef INITIALIZER

    #ifdef DEFINE_VARIABLES
    #define EXTERN                  /* nothing */
    #define INITIALIZER(...)        = __VA_ARGS__
    #else
    #define EXTERN                  extern
    #define INITIALIZER(...)        /* nothing */
    #endif /* DEFINE_VARIABLES */

### file1c.h

    #ifndef FILE1C_H_INCLUDED
    #define FILE1C_H_INCLUDED

    struct oddball
    {
        int a;
        int b;
    };

    extern void use_them(void);
    extern int increment(void);
    extern int oddball_value(void);

    #endif /* FILE1C_H_INCLUDED */

### file2c.h

    /* Standard prologue */
    #if defined(DEFINE_VARIABLES) && !defined(FILE2C_H_DEFINITIONS)
    #undef FILE2C_H_INCLUDED
    #endif

    #ifndef FILE2C_H_INCLUDED
    #define FILE2C_H_INCLUDED

    #include "external.h"   /* Support macros EXTERN and INITIALIZER */
    #include "file1c.h"     /* Type definition for struct oddball */

    /* Global variable declarations / definitions */
    EXTERN int global_variable INITIALIZER(37);
    EXTERN struct oddball oddball_struct INITIALIZER({ 41, 43 });

    /* Standard epilogue */
    #ifdef DEFINE_VARIABLES
    #define FILE2C_H_DEFINITIONS
    #undef DEFINE_VARIABLES     /* Safety first */
    #endif /* DEFINE_VARIABLES */

    #endif /* FILE2C_H_INCLUDED */

### file3c.c

    #define DEFINE_VARIABLES
    #include "file2c.h"  /* Variables now defined and initialized */

    int increment(void) { return global_variable++; }
    int oddball_value(void) { return oddball_struct.a + oddball_struct.b; }

### file4c.c

    #include "file2c.h"
    #include <stdio.h>

    void use_them(void)
    {
        printf("Global variable: %d\n", global_variable++);
        oddball_struct.a += global_variable;
        oddball_struct.b -= global_variable / 2;
    }

### file5c.c

    #include "file2c.h"     /* Declare variables */

    #define DEFINE_VARIABLES
    #include "file2c.h"  /* Variables now defined and initialized */

    int increment(void) { return global_variable++; }
    int oddball_value(void) { return oddball_struct.a + oddball_struct.b; }

### file6c.c

    #define DEFINE_VARIABLES
    #include "file2c.h"     /* Variables now defined and initialized */

    #include "file2c.h"     /* Declare variables */

    int increment(void) { return global_variable++; }
    int oddball_value(void) { return oddball_struct.a + oddball_struct.b; }

This scheme avoids most problems.  You only run into a problem if a
header that defines variables (such as `file2c.h`) is included by
another header (say `file7c.h`) that defines variables.  There isn't an
easy way around that other than "don't do it".

You can partially work around the problem by revising file2c.h to:

### file2c.h — revised

    /* Standard prologue */
    #if defined(DEFINE_VARIABLES) && !defined(FILE2C_H_DEFINITIONS)
    #undef FILE2C_H_INCLUDED
    #endif

    #ifndef FILE2C_H_INCLUDED
    #define FILE2C_H_INCLUDED

    #include "external.h"   /* Support macros EXTERN and INITIALIZER */
    #include "file1c.h"     /* Type definition for struct oddball */

    #if !defined(DEFINE_VARIABLES) || !defined(FILE2C_H_DEFINITIONS)

    /* Global variable declarations / definitions */
    EXTERN int global_variable           INITIALIZER(37);
    EXTERN struct oddball oddball_struct INITIALIZER({ 41, 43 });

    #endif /* !DEFINE_VARIABLES || !FILE2C_H_DEFINITIONS */

    /* Standard epilogue */
    #ifdef DEFINE_VARIABLES
    #define FILE2C_H_DEFINITIONS
    #undef DEFINE_VARIABLES         /* See discussion below */
    #endif /* DEFINE_VARIABLES */

    #endif /* FILE2C_H_INCLUDED */

The issue becomes 'should the header include `#undef DEFINE_VARIABLES`?'
If you omit that from the header and wrap any defining invocation with
`#define` and `#undef`:

    #define DEFINE_VARIABLES
    #include "file2c.h"
    #undef DEFINE_VARIABLES

in the source code (so the headers never alter the value of
`DEFINE_VARIABLES`, then you should be clean.  It is just a nuisance to
have to remember to write the the extra line.  An alternative might be:

    #define HEADER_DEFINING_VARIABLES "file2c.h"
    #include "externdef.h"

where `externdef.h` contains:

    #if defined(HEADER_DEFINING_VARIABLES)
    #define DEFINE_VARIABLES
    #include HEADER_DEFINING_VARIABLES
    #undef DEFINE_VARIABLES
    #undef HEADER_DEFINING_VARIABLES
    #endif /* HEADER_DEFINING_VARIABLES */

This is getting a tad convoluted, but seems to be secure (using the
revised version of `file2c.h`, and with no `#undef DEFINE_VARIABLES` in
the `file2c.h`).

### file7c.c

    /* Declare variables */
    #include "file2c.h"

    /* Define variables */
    #define HEADER_DEFINING_VARIABLES "file2c.h"
    #include "externdef.h"

    /* Declare variables - again */
    #include "file2c.h"

    /* Define variables - again */
    #define HEADER_DEFINING_VARIABLES "file2c.h"
    #include "externdef.h"

    int increment(void) { return global_variable++; }
    int oddball_value(void) { return oddball_struct.a + oddball_struct.b; }

### file8c.h

    /* Standard prologue */
    #if defined(DEFINE_VARIABLES) && !defined(FILE8C_H_DEFINITIONS)
    #undef FILE8C_H_INCLUDED
    #endif

    #ifndef FILE8C_H_INCLUDED
    #define FILE8C_H_INCLUDED

    #include "external.h"   /* Support macros EXTERN and INITIALIZER */
    #include "file2c.h"     /* struct oddball */

    #if !defined(DEFINE_VARIABLES) || !defined(FILE8C_H_DEFINITIONS)

    /* Global variable declarations / definitions */
    EXTERN struct oddball another INITIALIZER({ 14, 34 });

    #endif /* !DEFINE_VARIABLES || !FILE8C_H_DEFINITIONS */

    /* Standard epilogue */
    #ifdef DEFINE_VARIABLES
    #define FILE8C_H_DEFINITIONS
    #endif /* DEFINE_VARIABLES */

    #endif /* FILE8C_H_INCLUDED */

### file8c.c

    /* Define variables */
    #define HEADER_DEFINING_VARIABLES "file2c.h"
    #include "externdef.h"

    /* Define variables */
    #define HEADER_DEFINING_VARIABLES "file8c.h"
    #include "externdef.h"

    int increment(void) { return global_variable++; }
    int oddball_value(void) { return oddball_struct.a + oddball_struct.b; }

However, the problems are relatively unlikely to occur in practice,
especially if you take the standard advice to

# Avoid global variables

<hr>

Does this exposition miss anything?

_Confession_: The 'avoiding duplicated code' scheme outlined here was
developed because the issue affects some code I work on (but don't own),
and is a niggling concern with the scheme outlined in the first part of
the answer.  However, the original scheme leaves you with just two
places to modify to keep variable definitions and declarations
synchronized, which is a big step forward over having exernal variable
declarations scattered throughout the code base (which really matters
when there are thousands of files in total).  However, the code in the
files with the names `fileNc.[ch]` (plus `external.h` and `externdef.h`)
shows that it can be made to work.  Clearly, it would not be hard to
create a header generator script to give you the standardized template
for a variable defining and declaring header file.



  [1]: http://stackoverflow.com/questions/1410563/
  [2]: http://stackoverflow.com/questions/1490693/tentative-definitions-in-c99-and-linking
